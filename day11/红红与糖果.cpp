/*题目描述
红红生活在糖果国，糖果国每锋千年会从天上掉下来糖果，而在这一天红红在回宿舍的路上，忽然天上掉下大把大把的糖果。
红红实在是幸运了，糖果别的地方不落下，就只掉落在他身旁的10米范围内。糖果如果掉在了地上就消失了，
所以红红马上卸下身上的背包去接。但是由于路上两边尽头不能站人，所以他只能在路上接。
由于红红平时老待在宿舍玩自走棋，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，
每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：
为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。
开始时红红站在5这个位置，因此在第一秒，他只能接到456这三个位置中其中一个位置上的馅饼。
问红红最多可以接到并带回多少个糖果回宿舍（假设他的背包可以容纳无穷多个糖果） 
输入
输入数据有多组。每组数据的第一行为以正整数n(0<n<100000)，表示有n个糖果掉在这条路上。
在结下来的n行中，每行有两个整数x，T(0<T<100000)表示在第T秒有一个糖果掉在x点上。
同一秒钟在同一点上可能掉下多个糖果。n=0时输入结束。 
输出
每一组输入数据对应一行输出。输出一个整数m，表示红红最多可以接到多个糖果
提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。 
样例输入
6
5 1
4 1
6 1
7 2
7 2
8 3
0
样例输出
4
*/

#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

const int maxn = 100005;
int n;
int dp[maxn][11];
int date[maxn][11];
int _time, pie;

int main() {
    //freopen("test1.in", "r", stdin);
    //freopen("test1.out", "w", stdout);
    while (scanf("%d", &n) && n != 0) {
        memset(date, 0, sizeof date);
        memset(dp, 0, sizeof dp);
        int maxTime = 0;
        for (int i = 0; i < n; i++) {
            scanf("%d %d", &pie, &_time);
            date[_time][pie]++;
            maxTime = max(maxTime, _time);
        }
        //第一秒的运行时间，里面所有的运行情况
        dp[1][4] = date[1][4];
        dp[1][5] = date[1][5];
        dp[1][6] = date[1][6];

        //这里其实是由第二次运转的时间来看，因为第一秒的时间我已经全部标记下来了。
        for (int i = 2; i <= maxTime; i++) {
            for (int j = 0; j < 11; j++) {
                dp[i][j] = dp[i - 1][j];
                //不过需要注意的是 这些全部都是前几秒的动作，上一秒更新的状态，到下一秒后执行的状态
                //下面这个地方就是很奇幻的地方了，一共三个状态，取出来还是不取出来，就是这三种状态
                //左边一个位置取，还是右边一个位置取，还是原本的位置去出来。
                if (j > 0)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                if (j < 10)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1]);
                dp[i][j] += date[i][j];
            }
        }
        int Max = 0;
        for (int i = 0; i < 11; i++) {
            Max = max(Max, dp[maxTime][i]);
        }
        cout << Max << endl;
    }
    return 0;
}
