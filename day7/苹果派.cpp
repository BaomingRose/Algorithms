/*但是周期问题导致苹果对苹果派的味道加成不一样。苹果派的味道即苹果味道加成总和， 
即如果三个苹果加成的味道分别为 1， -1， 3 那苹果派最后的味道为3
但是今天客户下单的苹果派他不小心把苹果拿出来拿多了，
所以他需要拿掉一部分苹果，但是他希望尽可能的保持苹果派的味道变化小，
所以现在需要你编写一个程序来计算苹果派的味道问题。如果变化程度相同，
比如去掉一个苹果有， 苹果派的味道原来是 12， 有一个苹果是1， 
另一个苹果是 -1， 则选择去掉-1那个，苹果派味道变成13，
即使得苹果派的味道在变化小的情况尽可能变得更好。*/

/*但是周期问题导致苹果对苹果派的味道加成不一样。苹果派的味道即苹果味道加成总和，
即如果三个苹果加成的味道分别为 1， - 1， 3 那苹果派最后的味道为3
但是今天客户下单的苹果派他不小心把苹果拿出来拿多了，
所以他需要拿掉一部分苹果，但是他希望尽可能的保持苹果派的味道变化小，
所以现在需要你编写一个程序来计算苹果派的味道问题。如果变化程度相同，
比如去掉一个苹果有， 苹果派的味道原来是 12， 有一个苹果是1，
另一个苹果是 - 1， 则选择去掉 - 1那个，苹果派味道变成13，
即使得苹果派的味道在变化小的情况尽可能变得更好。*/

/*但是周期问题导致苹果对苹果派的味道加成不一样。苹果派的味道即苹果味道加成总和，
即如果三个苹果加成的味道分别为 1， -1， 3 那苹果派最后的味道为3
但是今天客户下单的苹果派他不小心把苹果拿出来拿多了，
所以他需要拿掉一部分苹果，但是他希望尽可能的保持苹果派的味道变化小，
所以现在需要你编写一个程序来计算苹果派的味道问题。如果变化程度相同，
比如去掉一个苹果有， 苹果派的味道原来是 12， 有一个苹果是1，
另一个苹果是 -1， 则选择去掉-1那个，苹果派味道变成13，
即使得苹果派的味道在变化小的情况尽可能变得更好。*/

#include<iostream>
using namespace std;
#include<cmath>

int a[100001] = { 0 };

void quickSort(int *a, int left, int right)
{
	if (left >= right)
	{
		return;
	}
	int i = left;
	int j = right;
	int key = a[left];
	while (i < j)
	{
		while (i < j && key <= a[j])
		{
			--j;
		}
		a[i] = a[j];
		while (i < j && key >= a[i])
		{
			++i;
		}
		a[j] = a[i];
	}
	a[i] = key;
	quickSort(a, left, i - 1);
	quickSort(a, i + 1, right);
}

int main()
{
	int n, m;
	int sum = 0;
	int front = 0, back = 0;
	while (cin >> n >> m)
	{
		for (int i = 0; i < n; ++i)
		{
			cin >> a[i];
			sum += a[i];
		}
		quickSort(a, 0, n - 1);
		for (int i = 0; i < n; ++i)
		{
			if (a[i] < 0)
				front = i + 1;
			if (a[i] > 0)
			{
				back = i;
				break;
			}
			if (a[i] == 0 && m > 0)
				--m;
		}
		while (m)
		{
			if (front == 0 && back >= 0)
			{
				sum -= a[back];
				++back;
				--m;
			}
			if (front && back == 0)
			{
				sum -= a[front - 1];
				--front;
				--m;
			}
			if (front && back)
			{
				if (abs(a[front - 1]) <= a[back])
				{
					sum -= a[front - 1];
					--front;
				}
				else
				{
					sum -= a[back];
					++back;
				}
				--m;
			}
		}
		cout << sum << endl;
		sum = 0;
		front = 0;
		back = 0;
	}
	return 0;
}



